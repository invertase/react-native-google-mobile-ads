# Mediation

AdMob Mediation is a feature lets you serve ads to your apps from multiple sources, including the AdMob Network and third-party ad sources, in one place. 
AdMob Mediation helps maximize your fill rate and increase your monetization by sending ad requests to multiple networks to verify you find the best 
available network to serve ads.

This guide walks you through configuring mediation using the `react-native-google-mobile-ads` library.

## Configure mediation in the AdMob UI

To configure mediation in the AdMob UI, complete the following steps:

1. Choose an ad source from the network details table ([Android](https://developers.google.com/admob/ios/choose-networks#network_details) | [iOS](https://developers.google.com/admob/android/choose-networks#network_details)).
2. Follow steps 1-2 of that ad source's integration guide.

## Install mediation adapters

For the Google Mobile Ads SDK to communicate with third-party ad networks, you need to include a mediation adapter for each network in your app. Each
adapter must be integrated in the Android and iOS layer of your application. To choose the adapters you want to install, see integrate open source and versioned adapters
([Android](https://developers.google.com/admob/android/choose-networks#integrate_open-source_and_versioned_adapters) | [iOS](https://developers.google.com/admob/ios/choose-networks#integrate_open-source_and_versioned_adapters)) copy the dependency into
your `build.gradle` file on Android and `Podfile` on iOS.

## Verify your setup with ad inspector

To verify your adapter are installed correctly, you can use ad inspector ([Android](https://developers.google.com/admob/android/ad-inspector) | [iOS](https://developers.google.com/admob/ios/ad-inspector))
in your react native application. To open the ad inspector from your React Native application, see [Ad inspector](https://docs.page/invertase/react-native-google-mobile-ads/ad-inspector) in the
`react-native-google-mobile-ads` documentation.

## Call native-specific methods from React

A third-party mediation adapter might have specific Android or iOS APIs that aren't exposed to your Reach Native code. In these cases, you can create a custom "bridge" to expose that native functionality.

This involves writing native code in both the iOS and Android layer.

### Android native code

On Android, create a **Module** class to contain your native logic and a **Package** class to register that module with your application.

1. Create the native module. This class contains the methods you want to call from JavaScript.

Example file: `android/app/src/main/java/com/your-app-name/`

The following example creates a **Module** class to use with `AppLovin`:

```
package com.your-app-name

import android.util.Log
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
// Import the necessary third-party SDKs.
import com.applovin.sdk.AppLovinPrivacySettings

class AppLovinMediationModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {

  // The React layer interfaces with the value of this API. 
  override fun getName() = "AppLovinMediation"

  // This exposes the method to the React layer.
  @ReactMethod
  fun setHasUserConsent(hasUserConsent: Boolean) {
    AppLovinPrivacySettings.setHasUserConsent(hasUserConsent)
  }
}
```

2. Create the package

    This class registers your module so React Native can find it.

Example file: `android/app/src/main/java/com/your-app-name/`

```
package com.your-app-name

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager
import java.util.Collections

class AppLovinMediationPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(AppLovinMediationModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return Collections.emptyList()
    }
}
```

3. Register the package

Add your new package in your `MainApplication` file:

```
override fun getPackages(): List<ReactPackage> =
  PackageList(this).packages.apply {
    // Add your custom package here.
    add(AppLovinMediationPackage())
}
```

### iOS native code

On iOS, create a header (`.h`) and an implementation (`.m`) file. The following example creates an `AppLovinMediation` class:

Example file: `ios/AppLovinMediation.h`

```
#import <React/RCTBridgeModule.h>

@interface AppLovinMediation : NSObject <RCTBridgeModule>
@end
```

Example file: `ios/AppLovinMediation.m`

```
#import "AppLovinMediation.h"
#import <Foundation/Foundation.h>
// Import the necessary third-party SDKs.
#import <AppLovinSDK/AppLovinSDK.h>

@implementation AdppLovinMediation

// The React layer interfaces with the class name, e.g. AppLovinMediation, by default. 
RCT_EXPORT_MODULE();

// This exports the method to the React layer.
RCT_EXPORT_METHOD(setHasUserConsent:(BOOL)hasUserConsent)
{
  [ALPrivacySettings setHasUserConsent:hasUserConsent];
}

@end
```

### Import native modules

In the JavaScript file where you want to call the native method, import `NativeModules` from the `react-native` library:

```
import { NativeModules } from 'react-native'
```

You can then access your module directly from the `NativeModules` object. The name you use here must exactly match the name
exposed by your native code.

The following example uses the `AppLovinMediation` sample class:

```
const { AppLovinMediation } = NativeModules
```

Once you have the module object, you can work with your object just as you would in Javascript.

```
AppLovinMediation.setHasUserConsent(false)
```
